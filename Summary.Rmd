---
date: "2014年10月11日"
documentclass: ctexart
output:
  pdf_document:
    fig_caption: yes
    latex_engine: xelatex
    number_sections: yes
    template: !expr rticles::ctex_template()
    toc: yes
classoption: "hyperref`r if (.Platform$OS.type != 'windows') ',nofonts'`"
---
#前言
相对于R在其他行业的流行，医学领域R应用更加少见，医学领域目前仍然以SPSS和SAS为主，本书主要目的在于介绍R在医学领域的应用。本书使用 markdown衍生版本R Markdown（Rmd）V2进行撰写，在TeXLive环境下使用xelatex编译，所有的R语言代码都基于knitr运行和生成。本书的所有代码都在R 3.2 下经过严格的测试。其中测试的操作系统为Linux Mint 17.2。在Linux Mint下安装R，需要安装如下依赖库和编译库

```{r eval=FALSE}
sudo apt-get install build-essential gfortran libxml2-dev 
libcurl4-openssl-dev libfreetype6-dev libbz2-dev liblapack-dev  
libpcre++-dev liblzma-dev r-cran-rcpp r-cran-rjava openjdk-7-* 
  libgmp3-dev libmysql++-dev libmpfr-dev libgdal1-dev libproj-dev 
libglu1-mesa-dev r-cran-boot r-cran-class r-cran-cluster 
r-cran-codetools r-cran-foreign r-cran-kernsmooth r-cran-lattice 
r-cran-mass r-cran-matrix r-cran-mgcv r-cran-nlme r-cran-nnet 
r-cran-rpart r-cran-spatial r-cran-survival r-cran-rodbc

#Step 1: Update Sources.List File
#- Edit the sources.list file
sudo gedit /etc/apt/sources.list
#- Add following entry
deb http://cran.rstudio.com/bin/linux/ubuntu trusty/
#Step 2: Add the Public Keys
gpg --keyserver keyserver.ubuntu.com --recv-key E084DAB9
gpg -a --export E084DAB9 | sudo apt-key add -
#Step 3: Install R-base
sudo apt-get update
sudo apt-get upgrade
sudo apt-get install r-base r-base-dev
```
安装Java的jdk时，在shell中运行 sudo R CMD javareconf命令，解决jdk安装问题。R 升级可通shell完成
```{r eval=FALSE}
sudo apt-get update
sudo apt-get upgrade
sudo apt-get install r-base
cp -r ~/R/x86_64-pc-linux-gnu-library/3.1/* 
  ~/R/x86_64-pc-linux-gnu-library/3.2 # at the shell prompt
update.packages(checkBuilt=TRUE, ask=FALSE) #at the R prompt 
```

本书涉及的R语言包较多，CRAN中包可通过下列方式一次性完成安装。
```{r eval=FALSE}
wants <- c("knitr","rmarkdown","devtools","epicalc","mosaic",
           "showtext","pander","PerformanceAnalytics","fitdistrplus",
           "CircStats","MASS","mixtools","boot","TrialSize","vcd",
           "ggplot2","pspearman","gvlma","car","lmtest","leaps",
           "plyr","bootstrap","elrm","rms","Deducer","bestglm",
           "survival","robust","mlogit","nnet","VGAM","ordinal",
           "Sample.Size","phia","mvtnorm","pscl","mosaic","XML",
           "pipeR","Rcmdr","rgl","HH","DescTools","multcomp",
           "effects","sandwich","qcc")

has   <- wants %in% rownames(installed.packages())
if(any(!has)) install.packages(wants[!has])
```
GitHub中R包通过以下方式进行安装
```{r eval=FALSE}
devtools::install_github("rstudio/rticles")
devtools::install_github("rstudio/rmarkdown")
```
bioconductor中R包通过以下方式进行安装
```{r eval=FALSE}
source("http://bioconductor.org/biocLite.R")
biocLite(c("GenomicFeatures", "AnnotationDbi","LBE"))
```
R-Forge等其它第三方源中的包，通过以下方式进行安装
```{r eval=FALSE}
install.packages("blotter", repos="http://R-Forge.R-project.org")
```
本书使用的R语言编译器是Rstudio，源代码托管于GitHub（https://github.com/xuefliang/RInMedicine）。
由于水平有限，书中难免有错误和疏漏之处，诚恳地期望各位专家和读者批评指正，深表感谢。

#描述性统计
```{r include=FALSE}
library(epicalc)
library(mosaic)
library(showtext)
library(pander)
library(PerformanceAnalytics)
library(Hmisc)
library(pastecs)
library(psych)
library(plyr)
library(doBy)
library(vcd)
library(gmodels)
library(readr)
library(stringr)
library(dplyr)
library(reshape2)
```

统计分析分为统计描述和统计推断两个部分，统计描述是通过绘制统计图、计算统计量等方法描述数据的分布特征，是数据分析的基本步骤。

## 常用统计量
###矩
设X和Y是随机变量，若$$E(X^{k}),k=1,2,\cdot \cdot \cdot $$存在，则称它为X的k阶原点矩，简称k阶矩。
若$$E\left \{ [X-E(x)]^{k} \right \},k=2,3,\cdot \cdot \cdot$$存在，则称它为X的k阶中心距。
若$$E(X^{k}Y^{l}),k,l=1,2,\cdot \cdot \cdot$$存在，则称它为X和Y的k+l阶混合距。
若$$E\left \{ [X-E(X)]^{k}[Y-E(Y)]^{l} \right \},k,l=1,2,\cdot \cdot \cdot$$存在，则称它为X和Y的k+l阶混合中心距。
X的数学期望E(X)是X的一阶原点矩，方差D(X)是X的二阶中心矩，协方差Cov(X,Y)是X和Y的二阶混合中心矩。
###  均值(Mean)
一阶原点矩又称均数是一组数据的平均值,均数（记为$\bar{x}$）定义为
$$\bar{X}=\frac{1}{n}\sum _{i=1}^{n}X_{i}$$
用它来描述正态分布数据的集中趋势。
### 标准差(Standard Deviation)
样本方差定义为$$S^{2}=\frac{1}{n-1}\sum_{i=1}^{n}(X_{i}-\bar{X})^{2}$$,标准差是方差的算术平方根，是一组数值自均数分散开来的程度的一种测量观念。定义为
$$\delta = \sqrt{\frac{1}{N}\sum_{i=1}^{n}(x_i-u)^2}$$
一个较大的标准差，代表大部分的数值和其平均值之间差异较大；一个较小的标准差，代表这些数值较接近平均值。
例 已知50名患者的收缩压（mmHg）分别为：
147 163 159 124 120  94 135 185 109 143 116 129 157 146 149 127 124 160 101 129 130 154 151
119 128 147 127 122 145 159 141 131 117 139 142 152 147 157 134 146 144 119 160 136 122 172
170 109 151 144
求血压的集中趋势和离散趋势及集中趋势的95%可信区间。
思路：先判断数据是否为正态分布，然后根据结果选择描述集中趋势的统计量。
```{r}
sbp <- c(147,163,159,124,120,94,135,185,109,143,116,129,157,146,149,
         127,124,160,101,129,130,154,151,119,128,147,127,122,145,159,
         141,131,117,139,142,152,147,157,134,146,144,119,160,136 ,
         122,172,170,109,151,144)
qqnorm(sbp)
qqline(sbp)
#plot(density(sbp)) 核密度
hist(sbp,freq = F) #freq=T,则绘制频数
result <- shapiro.test(sbp)
result
ks.test(sbp,"pnorm",mean(sbp),sd(sbp))
```
样本大小在3和5000之间,选择Shapiro-Wilk进行正态性检验。W值为`r result[1]`，P值为`r result[2]`大于0.05，不能拒绝其于正态分布一致的假设。如果样本数较大，可以选择Kolmogorov-Smirnov检验。对于服从正态分布的数据，选择均数和标准差描述其集中趋势和离散趋势。
```{r}
mean(sbp)
sd(sbp)
```
均值为`r mean(sbp)`,标准差为`r sd(sbp)`。对均数和标准差的计算还可以通过base包中的summary()函数，该函数提供了最小值、最大值、四分位数和数值型变量的均值，以及因子向量和逻辑型向量的频数统计。epicalc包中的summ()和mosaic包中的favstats()等函数也可获得类似结果，如favstats()一次就可以完成均数和标准差的计算。
```{r}
favstats(sbp)
```
对均数的95%可信区间的计算可通过t.test()获得，对一个给定的可信区间，它表示一个总体参数的估计范围。根据中位数和均数可以快速检查数据分布，如中位数小于均数，说明分布有可能向右倾斜。
```{r}
t.test(sbp)
```
通过设置conf.level=0.99，可以将可信区间水平提高到99%。
```{r}
t.test(sbp,conf.level=0.99)
```
###中位数(Median)
对于一组有限个数的数据来说，它们的中位数是这样的一种数：这群数据里的一半的数据比它大，而另外一半数据比它小。 计算有限个数的数据的中位数的方法是：把所有的同类数据按照大小的顺序排列。如果数据的个数是奇数，则中间那个数据就是这群数据的中位数；如果数据的个数是偶数，则中间那2个数据的算术平均值就是这群数据的中位数。通常用中位数来描述非正态分布数据的集中趋势，极值对中位数影响不大。定义为
实数$x_1$, $x_2$, $\dots$, $x_n$按大小顺序（顺序，降序皆可）排列为$x'_1$, $x'_2$, $\dots$ , $x'_n$、实数数列$x=(x_1, x_2, \dots , x_n)$的中位数$\mathrm{Q}_\frac{1}{2}(x)$为
$$\mathrm{Q}_\frac{1}{2}(x) = 
\begin{cases} 
 x'_\frac{n + 1}{2},                                  & \mbox{if } n \mbox{ is odd.} \\
 \frac{1}{2}( x'_\frac{n}{2} + x'_{\frac{n}{2} + 1}), & \mbox{if } n \mbox{ is even.} 
\end{cases}
$$
odd 为奇数，even 为偶数。
###四分位差(quartile deviation)
是上四分位数（QU，即位于75%）与下四分位数（QL，即位于25%）的差的一半。计算公式为：$Qd=QU-QL$。四分位差反映了中间50%数据的离散程度，其数值越小，说明中间的数据越集中；其数值越大，说明中间的数据越分散。四分位差不受极值的影响。
例 某地17名患者的月收入分别为：
23408 3468 1939 4360 23545 12233 4583 3546 35781 6578 8981 1345 5567 23455 23564 7623 14334
求收入的集中趋势和离散趋势及集中趋势的95%可信区间。
思路：仍然先判断数据是否为正态分布，然后根据结果选择描述集中趋势的统计量。
```{r}
income <- c(23408,3468,1939,4360,23545,12233,4583,3546,35781,6578,
            8981,1345,5567,23455, 23564,7623,14334)
qqnorm(income)
qqline(income)
#plot(density(income))
hist(income,freq = F)
result <- shapiro.test(income)
result
```
根据QQ图和Shapiro-Wilk进行正态性检验结果，W值为`r result[1]`，P值为`r result[2]`小于0.05，选择中位数和四分位差描述其集中趋势和离散趋势。
```{r}
quantile(income)
```
中位数为`r median(income)`，四分位差为75%的分位数减去25%的分位数。对中位数的可信区间估计，可通过wilcox.test()函数获得
```{r}
wilcox.test(income, conf.int=TRUE)
```
### 数学期望(mathematical expectation)
离散型随机变量：离散型随机变量的一切可能的取值$x_{i}$与对应的概率$P_{i}(=x_{i})$之积的和称为该离散型随机变量的数学期望，记为$E(X)$。数学期望是最基本的数学特征之一。它反映随机变量平均取值的大小
$$E(X)=\sum_{i}x_{i}p_{i}$$
连续型随机变量：若随机变量X的分布函数$F(x)$可表示成一个非负可积函数$f(x)$的积分，则称$X$为连续性随机变量，$f(x)$称为$X$的概率密度函数，积分值为X的数学期望，记为$E(X)$。
$$E(X)=\int_{-\infty }^{+\infty }xf(x)dx$$
###方差(Variance)
方差是各个数据与平均数之差的平方的平均数。在概率论和数理统计中，方差用来度量随机变量和其数学期望（即均值）之间的偏离程度。
设$X$为随机变量，如果$E{[X-E(X)]^2}$存在，则称$E{[X-E(X)]^2}$为$X$的方差，记为$Var(X)$。
离散型随机变量方差计算公式为$$Var(X)=E(X^{2})-(E(X))^{2}$$,连续型随机变量方差计算公式为$Var(x)=\int_{-\infty}^{+\infty} (x-E(X))^{2}f(x) \text{d}x=E(X^{2})-(E(X))^{2}$
例 计算样本(2,5,78,45,89,124)的方差
```{r}
s <- c(2,5,78,45,89,124)
var(s)
```
###众数(Mode)
观察资料中出现次数最多的数值或类别，不受极值影响，由于可能有不只一个，也可能没有众数，一般不适合进行统计分析。
例 计算样本(4,22,31,33,3,27,27,27,27,569,110,8,21,31,33,33)的众数
```{r}
S <- c(4,22,31,33,3,27,27,27,27,569,110,8,21,31,33,33)
names(which.max(table(S)))
```
###协方差(Covariance)
协方差用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况，即当两个变量是相同的情况。设$X$,$Y$为两个随机变量，称$E{[X-E(X)][Y-E(Y)]}$为$X$和$Y$的协方差，记录$Cov(X,Y)$。方差是协方差的一种特殊情况，即当两个变量是相同的情况。
$$Cov(X,Y)=E\left \{ [X-E(X)][Y-E(Y)] \right \}=E(XY)-E(X)E(Y)$$
例 计算X(2,5,7)和Y(6,7,9)的协方差。
```{r}
x <- c(2,5,7)
y <- c(6,7,9)
cov(x,y)
```
###相关系数(Correlation coefficient)
相关系数是用以反映变量之间相关关系密切程度的统计指标。相关系数是按积差方法计算，同样以两变量与各自平均值的离差为基础，通过两个离差相乘来反映两变量之间相关程度。当$Var(X)>0, Var(Y)>0$时，称$Cov(X,Y)/sqrt(Var(X)*Var(Y))$为$X$与$Y$的相关系统。
$$\rho (X,Y)=\frac{Cov(X,Y)}{\sqrt{Var(X)Var(Y)}}$$
例 计算X(2,5,7)和Y(6,7,9)的相关系数
```{r}
x <- c(2,5,7)
y <- c(6,7,9)
cor(x,y)
```
### 偏度(skewness)
是统计数据分布偏斜方向和程度的度量，是统计数据分布非对称程度的数字特征。设分布函数$F(x)$有中心矩$\mu_{2}=E(X-E(X))^2$,$\mu_{3}=E(X-E(X))^3$,则$\frac{\mu_{3}}{\mu_{2}^{\frac{3}{2}}}$为偏度系数。当$C_{s}$>0时，概率分布偏向均值右则,$C_{s}$<0时，概率分布偏向均值左则。
$$C_{s}=\frac{\mu_{3}}{\mu_{2}^{\frac{3}{2}}}$$
###峰度(kurtosis)
表征概率密度分布曲线在平均值处峰值高低的特征数。峰度刻划不同类型的分布的集中和分散程序。设分布函数$F(x)$有中心矩$\mu_{2}=E(X-E(X))^2$, $\mu_{4}=E(X-E(X))^4$，则$C_{k}=\frac{\mu_{4}}{\mu_{2}^{2}}-3$为峰度系数。
$$C_{k}=\frac{\mu_{4}}{\mu_{2}^{2}}-3$$
例 计算10000个正态分布的样本的偏度和峰度
```{r}
S<-rnorm(10000)
skewness(S)
kurtosis(S)
hist(S,breaks=100)
```
###几何平均数（Geometric mean）
是n个变量值连乘积的n次方根,是用于反映一组经对数转换后呈对称分布的变量值在数量上的平均水平即对数正态分布数据，在医学研究中常适用于免疫学的指标。对于变量值呈倍数关系或呈对数正态分布（正偏态分布），如抗体效价及抗体滴度，某些传染病的潜伏期，细菌计数等，宜用几何均数表示其平均水平。
$$H=G=\sqrt[n]{X_{1}*X_{2}*...*X_{n}}=\sum \sqrt[n]{\prod_{i=1}^{n}X_{n}}$$
例 5名学龄儿童的麻疹血凝抑制抗体滴度为1：25，1：50，1：50，1：100，1：400，求几何均数及标准差。
```{r}
geomean <- function(x, na.rm = FALSE, trim = 0, ...)
{
  exp(mean(log(x, ...), na.rm = na.rm, trim = trim, ...))
}
geosd <- function(x, na.rm = FALSE, ...)
{
  exp(sd(log(x, ...), na.rm = na.rm, ...))
}
s<-c(25,50,50,100,400)
shapiro.test(log(s))
geomean(s)
geosd(s)
```
也可以安装NCStats包，调用geomean和geosd()函数。
###变异系数（Coefficient of Variation）
是刻画数据相对分散性的一种度量，记为$c_v$,是概率分布离散程度的一个归一化量度，其定义为标准差$\ \sigma$与平均值$\ \mu$ 之比
$$c_v = {\sigma \over \mu }$$
###样本校正平方和（CSS）
样本与均值差的平方的求和$CSS=\sum_{i=1}^{n}(x_{i}-\overline{x})$
###样本未校正平方和（USS）
样本值平方的求和$USS=\sum_{i=1}^{n}x_{i}^{2}$
###标准误（Standard Deviation）
是某种统计量在抽样分布上的标准差称为该种统计量的标准误，即样本统计量的标准差，是描述对应的样本统计量抽样分布的离散程度及衡量对应样本统计量抽样误差大小的尺度。设n个测量值的误差为v1、v2……vn，则这组测量值的标准误差$\sigma$
$$\sigma =\sqrt{\frac{1}{n-1}\sum_{i=1}^{n}v_{i}^2}$$
###极差
描述样本分散性，数据越分散，其极差越大。
$$R=max(x)-min(x)$$
例 对例1求变异系数、样本校正平方和、样本未校正平方和、极差和均值的标准误。
```{r}
cv <- 100*sd(sbp)/mean(sbp)
cv
css <- sum((sbp-mean(sbp))^2)
css
uss <- sum(sbp^2)
uss
r <- max(sbp)-min(sbp)
r
```
通常由于总体的均数或总体的方差并不知道，样本均值的标准误$SD=\frac{s}{\sqrt{n}}$,s为标准差，n为样本数。
```{r}
sd <- sd(sbp)/sqrt(length(sbp))
sd
```
###数据中心化和标准化
数据中心化是将某变量中的观察值减去该变量的平均数，数据标准化将某变量中的观察值减去该变量的平均数，然后除以该变量的标准差。经标准化的数据都是没有单位的纯数量。对变量进行的标准差标准化可以消除量纲（单位）影响和变量自身变异的影响。
例 对下表中三科成绩进行标准化。
Math  Science	English
---   ---     ---
502	  95	    25
465	  67      12
621	  78      22
575	  66      18
454	  96      15
634	  89      30
576	  78      37
421	  56      12
599	  68      22
666	  100     38

R语言中scale()函数可以实现数据标准化，两个参数center和scale为True分别表示计算中心化和标准化
```{r}
Math <- c(502,465,621,575,454,634,576,421,599,666)
Science <- c(95,67,78,66,96,89,78,56,68,100)
English <- c(25,12,22,18,15,30,37,12,22,38)

Student <- as.data.frame(cbind(Math,Science,English))

options(digits=2) #限定为2位小数
scale(Student[,1:3],center = T,scale = F) #数据中心化 
scale(Student[,1:3],center = F,scale = T) #数据标准化
```
apply()函数或sapply()函数计算所选择的任意描述性统计量。对于sapply()函数，其使用格式为：sapply(x,FUN,options)其中的x是输入的数据框（或矩阵），FUN为一个任意的函数。如果指定了options，它们将被传递给FUN。你可以在这里插入的典型函数有mean、sd、var、min、max、median、length、range和quantile。可以根据需要自定义需要的统计量，如下
```{r}
mystats <- function(x, na.omit = FALSE) {
  if (na.omit) 
    x <- x[!is.na(x)]
  m <- mean(x)
  n = length(x)
  s <- sd(x)
  skew <- sum((x - m)^3/s^3)/n
  kurt <- sum((x - m)^4/s^4)/n - 3
  return(c(n = n, mean = m, stdev = s, skew = skew, kurtosis = kurt))
}

data(drugDat,package = "elrm")
sapply(drugDat,mystats)
```
Hmisc包中的describe()函数可返回变量和观测的数量、缺失值和唯一值的数目、平均值、分位数，以及五个最大的值和五个最小的值。pastecs包中有一个名为stat.desc()的函数，它可以计算种类繁多的描述性统计量。使用格式为：stat.desc(x,basic=TRUE,desc=TRUE,norm=FALSE,p=0.95)其中的x是一个数据框或时间序列。若basic=TRUE（默认值），则计算其中所有值、空值、缺失值的数量，以及最小值、最大值、值域，还有总和。若desc=TRUE（同样也是默认值），则计算中位数、平均数、平均数的标准误、平均数置信度为95%的置信区间、方差、标准差以及变异系数。最后，若norm=TRUE（不是默认的），则返回正态分布统计量，包括偏度和峰度（以及它们的统计显著程度）和Shapiro–Wilk正态检验结果。这里使用了p值来计算平均数的置信区间（默认置信度为0.95）。psych包也拥有一个名为describe()的函数，它可以计算非缺失值的数量、平均数、标准差、中位数、截尾均值、绝对中位差、最小值、最大值、值域、偏度、峰度和平均值的标准误。

##数据操作
###数据输入
readr包中的函数使数据读入的速度更快，相对于基础包中的函数，对字符类型并不需要指定stringsAsFactors = FALSE防止字符类型自动转为因子，对列名限制更少。固定分割的数据使用read_delim(), read_csv(), read_tsv()和read_csv2()函数，固定宽度的数据使用read_fwf()和 read_table()。
```{r warning=F}
WHO<- read_csv("WHO.csv",col_names=T) #col_names相当于header=T，默认为True
#可以从压缩包或网站上直接输入
mtcars <- read_csv(system.file("extdata/mtcars.csv.bz2", package = "readr"))
#mtcars <- read_csv("https://github.com/hadley/readr/raw/master/inst/extdata/mtcars.csv")
```
###数据输出
用readr包读入的数据，变量的引用使用如下格式WHO$`Adolescent fertility rate (%)`，不同于通常的引用。write_csv()将数据框快速的输出为csv文件。
```{r}
who <- read_csv("WHO.csv", col_types = list(
  CountryID = col_integer(),
  Continent=col_double(),
  Country=col_factor(c("Country")) 
  #col_date() 使用Y-m-d格式，col_datetime()使用 ISO8601日期时间格式
))
class(who) #tbl_df、tbl和data.frame类型
```
###字符串操作
####合并字符串
```{r}
IT <- c("google","baidu","bing")
res <- str_c(1:3,IT,sep=' ',collapse=' ')
str_c('My work place is ',res,collapse=' ')
```
####计算字符串长度
```{r}
str_length(c("programming R and Python", 123,res))
```
####按位置取子字符串
```{r}
str_sub(IT, 1, 3)
```
####子字符串重新赋值
```{r}
capital <-toupper(str_sub(IT,1,1))
str_sub(IT, rep(1,3),rep(1,3)) <- capital 
```
####重复字符串
```{r}
str_dup(IT, c(2,3,4))
```
####加空白和去除空白
```{r}
str_pad(IT, 10, "both")
str_trim(IT)
```
####根据正则表达式检验是否匹配
```{r}
str_detect(IT, "g$")  #查找以g结尾
str_detect(IT, "[aiu]") #查找是否包含a、i、u
```
####查找匹配的字符串位置
```{r}
str_locate(IT, "a")  #返回起始和结束的位置
```
####提取匹配的部分
```{r}
str_extract(IT, "[a-z]+")
str_extract(IT, "[a-z]{1,3}")
str_match(IT, "[a-z]+")
```
####替换匹配的部分
```{r}
str_replace(IT, "[aeiou]", "-")
```
####分割
```{r}
str_split(res, " ")
```
###数据操作
dplyr包将plyr包中的ddply()等函数进一步分离强化,专注接受dataframe对象,大幅提高了运算速度,并且提供了更稳健的与其它数据库对象间的接口。

####数据集类型
将过长过大的数据集转换为显示更友好的tbl_df类型
```{r}
iris_df<- tbl_df(iris)
iris_df
```
####筛选
filter 用于选择满足条件的观测（行），第一个参数是 data frame 名字，第二个参数是条件。
```{r}
#选取 Species == versicolor的观测
filter(iris_df, Species == "versicolor") 
#选取Sepal.Length为7.0，5.2，6.6的观测
filter(iris_df, Sepal.Length %in% c(7.0, 5.2,6.6)) 
```
对于多条件的选择，需要完整条件的，然后使用集合运算符将条件拼接起来。集合运算符有 !、|、&、xor(交补)。条件的判断符有>(=)、<(=)、==、!=、%in% (判断元素是否在集合或者列表内，返回逻辑值)。
```{r}
filter(iris_df, Sepal.Length>=6.3 & Species=="versicolor")
```
####排列
arrange 用于根据变量排序，如果排序依据（列）是字符，按照字母表的顺序，如果是数字，默认按照从小到大的顺序排序，如果需要使用逆序排，可以使用desc(var) 或者 -var。
```{r}
arrange(iris_df, Petal.Length)
arrange(iris_df, desc(Petal.Length))
```
####选择
select 用于选择列,类似于R自带的 subset() 函数,select中负号表示不选择。其中变量的声明还有其他形式，比如B:F表示从 B 列到 F 列所有列；ends_with("string") 表示选取列名以 string 结尾的全部列；contains("string") 表示选取列名中含有 string 的所有列。
```{r}
select(iris_df, Petal.Length)
```
####变形
mutate用于添加新的变量，直接使用列名进行计算得到新变量即可。可使用刚添加的变量，也就是在一个语句中可以多个变量，而且变量可以来源于刚新建的变量。
```{r}
mutate(iris_df, double=Petal.Length*2,quadruple=double*2)
```
####分类汇总
summarise可以用于分类汇总,实际上它是把 data frame 依据分组依据拆分成多个data frame，然后对每data frame 分别计算，类似于ddply。summarise 可以使用的函数有：min(x), median(x), max(x), quantile(x, p)，计算个数n(), 计算 x 中唯一值的个数n_distinct(), sum(x), mean(x),sum(x > 10), mean(x > 10),sd(x), var(x), iqr(x), mad(x)
```{r}
group <- group_by(iris_df, Species)  # 分组依据
summarise(group, Speciessum = sum(Sepal.Length), 
          Speciesmean=mean(Petal.Length, na.rm = TRUE)) #分组求和
```
####管道操作
%>%与pipeR和magrittr包中%>%操作符一样，用来将上一步产生的对象管道输出为下一步调用的函数的第一个参数。
```{r}
iris_df %>% group_by(Species) %>% 
  summarise(total = sum(Sepal.Length)) %>%
  arrange(desc(total)) %>%head(5)
```
####变量查重
通常用select指定需要查重的变量，distinct返回没有重复的数据。
```{r}
#Sepal.Length,Species这两列中没有重复的数据
distinct(select(iris_df, Sepal.Length,Species)) 
```
####随机抽样
使用sample_n和sample_frac从数据框中随机的返回一些行，sample_n按指定的行数返回，sample_frac按指定的比例返回。
```{r}
sample_n(iris, 10)  #返回10行
sample_frac(iris, 0.01) #返回总行数的0.01倍
```
###长宽格式数据转换
在wide format中，每一个样本点(subject)自成一行，这一行内记录了这个样本点的所有信息。典型的宽格式数据如下：
```{r}
data_wide <- read.table(header=TRUE, text='
 subject sex control cond1 cond2
       1   M     7.9  12.3  10.7
       2   F     6.3  10.6  11.1
       3   F     9.5  13.1  13.8
       4   M    11.5  13.4  12.9
')
data_wide
```
long format把wide format中的某几个numerical variables变成了一个factor variable之下的levels，而这几个numerical variables的取值都被集中在了一个变量之下。reshape2包中melt函数把wide format变成long format。
```{r}
data_long <- melt(data_wide,
     id.vars = c('subject', 'sex'),
          #ID variables 是指将被保存在long format中的变量,它起到指示样本点的作用
     variable.name = 'condition', 
     value.name = 'measurement')
data_long
```
在long format中，每个样本点被拆成了三个行，两个新的变量出现。第一个新变量是一个factor variable，fator levels是wide format中的三个变量。第二个新变量是一个numeric variable，记录的数值对应于wide format中该样本点在control, cond1, cond2三列的取值。除了id.variable之外，其他变量都被变成了long format的形式,数据的长短是相对的，如果把没有转换的sex变量转换掉，数据将变得更长。
```{r}
melt(data_wide, id.vars = 'subject')
```
Wide format转换为long format时，最极端的情况是所有变量都转换掉
```{r}
melt(data_wide, id.vars = NULL)
```
reshape2包中Cast函数把long format变成wide format的函数，dcast针对data.frame，acast针对的是array或matrices。dcast中需要一个formular来说明转换的形式，formular的左边是id variables，右边是一个factor variables，它的factor levels将会在wide format中成为新的variables，这些variables的取值用value.var来指定，最后得到的wide format如下：
```{r}
data.wide <- dcast(data_long, subject + sex ~ condition, value.var = "measurement")
data.wide
```
###分类汇总
在比较多组个体或观测时，关注的焦点经常是各组的描述性统计信息，而不是整体的描述性统计信息时，可以使用aggregate()分组获取描述性统计量。
例 epicalc中HW93数据集是1993年泰国南部钩虫感染的调查资料，其中intense变量表示感染的严重程度为有序多分类变量，egp为感染的数量，shoes表示是否穿鞋，agegr是年龄分组,需要计算每个年龄的构虫平均感染钩虫的数量。
使用aggregate()分组获取描述性统计量
```{r}
data(HW93,package = "epicalc")
aggregate(HW93$epg,by=list(epg=HW93$agegr),mean)
```
注意list(epg=HW93$age)的使用。如果使用的是list(HW93$age)，则age列将被标注为Group.1而不是age。如果有多个分组变量，可以使用by=list(name1=groupvar1, name2=groupvar2, ... , groupvarN)这样的语句。aggregate()仅允许在每次调用中使用平均数、标准差这样的单返回值函数。
doBy包和psych包也提供了分组计算描述性统计量的函数，doBy包中summaryBy()函数的使用格式为：summaryBy(formula,data=dataframe,FUN=function) 其中的formula接受以下的格式：var1+var2+…+varN~grounpvar1+goupvar2+…+groupvarN,在~左侧的变量是需要分析的数值型变量，而右侧的变量是类别型的分组变量。function可为任何内建或用户自编的R函数。psych包中的describe.by()函数可计算和describe相同的描述性统计量，只是按照一个或多个分组变量分层，使用psych包中的describe.by()和使用doBy包中的summaryBy()分组计算概述统计量如下，describe.by()函数不允许指定任意函数，所以它的使用范围较窄。若存在一个以上的分组变量，你可以使用list(groupvar1, groupvar2, ... , groupvarN)来表示它们。但这仅在分组变量交叉后不出现空白单元时有效。
```{r}
summaryBy(epg~agegr,data=HW93,FUN=max)
describe.by(HW93$epg,HW93$agegr)
```
需要使用复杂函数则需要plyr包中的*ply族函数。该函数将这类任务以“分割-应用-结合”这种三步方式进行处理：通过一种或多种factor将数据集进行分割，而后应用某项函数，最后将结果整合回数据集当中。Plyr包中囊括了一整套“ply”函数，其第一个字母表示输入的类型，第二个字母表示输出的类型，输入:array,dataframe,list三种格式，输出: array,dataframe,list,discareded四种格式。plyr包中的ddply()可以得到相同结果。summarize不会提供来自原始数据框中其它列中的任何信息，如果需要列出其它column数据，则可以把“summarize”替换为“transform”，且允许一次应用多个函数。
```{r eval=FALSE}
ddply(.data = HW93,.(agegr),summarize,mean=mean(epg),max=max(epg),min=min(epg))

rate <- function(x){
  return(sum(x,na.rm = T)/length(x))
}
ddply(.data = HW93,.(agegr),.fun = function(x){rate(x$epg)})
```
##频数表和列联表
table(var1, var2, …, varN) 使用 N 个类别型变量（因子）创建一个 N 维列联表。xtabs(formula, data) 根据一个公式和一个矩阵或数据框创建一个 N 维列联表。prop.table(table, margins) 依margins定义的边际列表将表中条目表示为分数形式。margin.table(table, margins) 依margins定义的边际列表计算表中条目的和addmargins(table, margins) 将概述边margins（默认是求和结果）放入表中。ftable(table) 创建一个紧凑的“平铺”式列联表
###一维列联表
```{r}
data(Arthritis,package = "vcd")
pander(head(Arthritis))
mytable<-with(Arthritis,table(Improved))
mytable
```
可以用prop.table()将这些频数转化为比例值
```{r}
prop.table(mytable)
```
###二维列联表
对于二维列联表，table()函数的使用格式为：table(A,B),其中的A是行变量，B是列变量。xtabs()函数还可使用公式风格的输入创建列联表，格式为：xtabs(\~A+B,data=mydata)，其中的mydata是一个矩阵或数据框，要进行交叉分类的变量应出现在公式的右侧（即\~符号的右方），以+作为分隔符。若某个变量写在公式的左侧，则其为一个频数向量（在数据已经被表格化时很有用）。
```{r}
mytable<-xtabs(~Treatment+Improved,data=Arthritis)
mytable
```
可以使用margin.table()和prop.table()函数分别生成边际频数(行和)和比例(行比)。
```{r}
margin.table(mytable,1)
prop.table(mytable,1)
```
列和与列比例可以这样计算
```{r}
margin.table(mytable,2)
prop.table(mytable,2)
```
各单元格所占比例可用如下语句获取
```{r}
prop.table(mytable)
```
可以使用addmargins()函数为这些表格添加边际和
```{r}
addmargins(mytable)
addmargins(prop.table(mytable))
```
在使用addmargins()时，默认是表中所有的变量创建边际和
```{r}
addmargins(prop.table(mytable,1),2)
```
注意 table()函数默认忽略缺失值（NA）。要在频数统计中将NA视为一个有效的类别，请设定参数useNA="ifany"。
```{r}
table(Arthritis$Treatment,Arthritis$Improved,useNA = "ifany")
```
使用gmodels包中的CrossTable()函数生成二维列联表
```{r}
CrossTable(Arthritis$Treatment,Arthritis$Improved)
```
CrossTable()函数有很多选项计算（行、列、单元格）的百分比；指定小数位数；进行卡方、Fisher和McNemar独立性检验；计算期望和（皮尔逊、标准化、调整的标准化）残差；将缺失值作为一种有效值；进行行和列标题的标注;

###多维列联表
table()和xtabs()都可以基于三个或更多的类别型变量生成多维列联margin.table()、prop.table()和addmargins()函数也可以推广到多维的情况。另外，ftable()函数可以以一种紧凑而吸引人的方式输出多维列联表
```{r}
mytable<-xtabs(~Treatment+Sex+Improved,data=Arthritis)
mytable
ftable(mytable)
margin.table(mytable,c(1,3))#治疗情况（Treatment） × 改善情况（Improved）的边际频数
```

```{r,echo=FALSE}
try(detach(package:epicalc))
try(detach(package:mosaic))
try(detach(package:showtext))
try(detach(package:pander))
try(detach(package:PerformanceAnalytics))
try(detach(package:Hmisc))
try(detach(package:pastecs))
try(detach(package:psych))
try(detach(package:plyr))
try(detach(package:doBy))
try(detach(package:vcd))
try(detach(package:gmodels))
try(detach(package:readr))
try(detach(package:stringr))
try(detach(package:dplyr))
try(detach(package:reshape2))
```

#常用数据分布
```{r include=FALSE}
library(fitdistrplus)
library(CircStats)
library(ggplot2)
```

如果给定一种概率分布，通常会有四类计算问题：计算其概率密度density(d);计算其概率分布probability(p);计算其百分位数quantile(q);随机数模拟random(r),R中常见的函数、分布和参数如下

R funciton    Distribution	       Parameters
----          ----                 ----
beta	        beta	               shape1,shape2
binom	        binomial	           sample,size,probability
cauchy	      Cauchy	             location,scale
exp	          exponential	         rate(optional)
chisq	        Chi-squared	         degrees of freedom
f	            Fisher's F	         df1,df2
gamma	        gamma	               shape
geom	        geometric	           probability
hyper	        hypergeometric	     m,n,k
lnorm	        lognormal	           mean,standard deviation
logis	        logistic	           location,scale
nbinom	      negative binomial    size,probability
norm	        normal	             mean,standard deviation
pois	        Poisson	             mean
signrank    	Wilcoxon signed rank sample size n
t	            Student's t	         degree of freedom
unif	        uniform	             minimum,maximum(opt.)
weibull	      Weibull	             shape
wilcox	      Wilcoxon rank sum    m,n

##正态分布(Normal distribution)
又名高斯分布(Gaussian distribution)，是一个在数学、物理及工程等领域都非常重要的概率分布，在统计学的许多方面有着重大的影响力。若随机变量X服从一个数学期望为$μ$、方差为$\sigma^2$的正态分布，记为$N(u，\sigma^2)$。其概率密度函数为正态分布的期望值$u$决定了其位置，其标准差$\sigma^2$决定了分布的幅度。因其曲线呈钟形，因此人们又经常称之为钟形曲线。我们通常所说的标准正态分布是$u$ = 0,$\sigma$ = 1的正态分布。
概率密度函数
$$f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma ^2}}$$
```{r}
fun1 <- function(x){
  y <- dnorm(x,mean = 0,sd = 1)
  return(y)
}
  
fun2 <- function(x){
  y <- dnorm(x,mean = 0,sd = 0.5)
  return(y)
} 

fun3 <- function(x){
  y <- dnorm(x,mean = 0,sd = 2)
  return(y)
} 

ggplot(NULL, aes(x=x, colour = g)) +
  stat_function(data = data.frame(x = -5:5, g = factor(1)), fun = fun1) +
  stat_function(data = data.frame(x = -5:5, g = factor(2)), fun = fun2) +
  stat_function(data = data.frame(x = -5:5, g = factor(3)), fun = fun3) +
  scale_colour_manual(values = c("red", "green","blue"), 
                      labels = c("red","green","blue"))+ylab(label = "density")+
  labs(title="The Normal Density Distribution")
```

累积分布函数
$$F(x;u,\sigma )=\frac{1}{\sqrt{2\pi}\sigma} \int_{-\infty }^{x}exp(-\frac{(t-u)^2}{2\sigma ^2})dt$$
```{r}
fun1 <- function(x){
  y <- pnorm(x,mean = 0,sd = 1)
  return(y)
}
  
fun2 <- function(x){
  y <- pnorm(x,mean = 0,sd = 0.5)
  return(y)
} 

fun3 <- function(x){
  y <- pnorm(x,mean = 0,sd = 2)
  return(y)
} 

ggplot(NULL, aes(x=x, colour = g)) +
  stat_function(data = data.frame(x = -5:5, g = factor(1)), fun = fun1) +
  stat_function(data = data.frame(x = -5:5, g = factor(2)), fun = fun2) +
  stat_function(data = data.frame(x = -5:5, g = factor(3)), fun = fun3) +
  scale_colour_manual(values = c("red", "green","blue"), 
                      labels = c("red", "green","blue"))+
  ylab(label = "density")+
  labs(title="The Normal Cumulative Distribution")
```
分布检验
Shapiro-Wilk正态分布检验: 用来检验是否数据符合正态分布，类似于线性回归的方法一样，是检验其于回归曲线的残差。该方法推荐在样本量很小的时候使用，样本在3到5000之间。该检验原假设为$H_{0}$:数据集符合正态分布，统计量W为：
$$W=\frac{(\sum_{i=1}^{n}a_{i}x_{(i)})^2}{\sum_{i=1}^{n}(x_{i}-\bar{x})^2}$$
统计量W 最大值是1，越接近1，表示样本与正态分布匹配,p值，如果p-value小于显著性水平$\alpha$(0.05)，则拒绝$H_{0}$
```{r}
set.seed(1)
S<-rnorm(1000)
shapiro.test(S)
```
结论: W接近1，p-value>0.05，不能拒绝原假设，所以数据集S符合正态分布！

Kolmogorov-Smirnov连续分布检验:检验单一样本是不是服从某一预先假设的特定分布的方法。以样本数据的累计频数分布与特定理论分布比较，若两者间的差距很小，则推论该样本取自某特定分布族。该检验原假设为$H_{0}$:数据集符合正态分布，$H_{1}$:样本所来自的总体分布不符合正态分布。令$F0(x)$表示预先假设的理论分布，$Fn(x)$表示随机样本的累计概率(频率)函数.
统计量D为: $D=max|F0(x) - Fn(x)|$
D值越小，越接近0，表示样本数据越接近正态分布,p值，如果p-value小于显著性水平$\alpha$(0.05)，则拒绝H_{0}
```{r}
set.seed(1)
S<-rnorm(1000)
ks.test(S, "pnorm")
```
结论: D值很小, p-value>0.05，不能拒绝原假设，所以数据集S符合正态分布！

## 指数分布
指数分布(Exponential distribution)用来表示独立随机事件发生的时间间隔，比如旅客进机场的时间间隔、中文维基百科新条目出现的时间间隔等等。许多电子产品的寿命分布一般服从指数分布。有的系统的寿命分布也可用指数分布来近似。它在可靠性研究中是最常用的一种分布形式。指数分布是伽玛分布和weibull分布的特殊情况，产品的失效是偶然失效时，其寿命服从指数分布。指数分布可以看作当weibull分布中的形状系数等于1的特殊分布，指数分布的失效率是与时间t无关的常数，所以分布函数简单。
概率密度函数
$$f(x;\lambda)=\left\{\begin{matrix} \lambda e^{-\lambda x},x>=0
 &  & \\ 0,x<0
\end{matrix}\right.$$
其中$\lambda$> 0是分布的一个参数，常被称为率参数（rate parameter）。即每单位时间发生该事件的次数。指数分布的区间是$[0,\infty)$。 如果一个随机变量X 呈指数分布，则可以写作：$X$ ~ Exponential（$\lambda$）。
```{r}
fun1 <- function(x){
  y <- dexp(x,0.5)
  return(y)
}
  
fun2 <- function(x){
  y <- dexp(x,1)
  return(y)
} 

fun3 <- function(x){
  y <- dexp(x,2)
  return(y)
} 

ggplot(NULL, aes(x=x, colour = g)) +
  stat_function(data = data.frame(x=seq(0,3,length.out=100), 
                                  g = factor(1)), fun = fun1) +
  stat_function(data = data.frame(x=seq(0,3,length.out=100), 
                                  g = factor(2)), fun = fun2) +
  stat_function(data = data.frame(x=seq(0,3,length.out=100), 
                                  g = factor(3)), fun = fun3) +
  scale_colour_manual(values = c("red", "green","blue"), 
                      labels = c("red", "green","blue"))+
  ylab(label = "density")+
  labs(title="The Exponential Density Distribution")
```
累积分布函数
$$F(x;\lambda)=\left\{\begin{matrix} 1-e^{\lambda x},x>=0
 &  & \\ 0,x<0
\end{matrix}\right.$$
```{r}
fun1 <- function(x){
  y <- pexp(x,0.5)
  return(y)
}
  
fun2 <- function(x){
  y <- pexp(x,1)
  return(y)
} 

fun3 <- function(x){
  y <- pexp(x,2)
  return(y)
} 

ggplot(NULL, aes(x=x, colour = g)) +
  stat_function(data = data.frame(x=seq(0,3,length.out=100), 
                                  g = factor(1)), fun = fun1) +
  stat_function(data = data.frame(x=seq(0,3,length.out=100), 
                                  g = factor(2)), fun = fun2) +
  stat_function(data = data.frame(x=seq(0,3,length.out=100), 
                                  g = factor(3)), fun = fun3) +
  scale_colour_manual(values = c("red", "green","blue"), 
                      labels = c("red", "green","blue"))+
  ylab(label = "density")+
  labs(title="The Exponential Cumulative Distribution Function")
```
分布检验
Kolmogorov-Smirnov连续分布检验:检验单一样本是不是服从某一预先假设的特定分布的方法。以样本数据的累计频数分布与特定理论分布比较，若两者间的差距很小，则推论该样本取自某特定分布族。该检验原假设为$H_{0}$:数据集符合指数分布，$H_{1}$:样本所来自的总体分布不符合指数分布。令$F0(x)$表示预先假设的理论分布，$Fn(x)$表示随机样本的累计概率(频率)函数.
统计量D为: $D=max|F0(x) - Fn(x)|$
D值越小，越接近0，表示样本数据越接近指数分布,p值，如果p-value小于显著性水平$\alpha$(0.05)，则拒绝$H_{0}$
```{r}
set.seed(1)
S<-rexp(1000)
ks.test(S, "pexp")
```
结论: D值很小, p-value>0.05，不能拒绝原假设，所以数据集S符合指数分布！

##γ(伽玛)分布
伽玛分布(Gamma)是著名的皮尔逊概率分布函数簇中的重要一员，称为皮尔逊Ⅲ型分布。它的曲线有一个峰，但左右不对称。伽玛分布中的参数α，称为形状参数，β称为尺度参数。
$$Ga(x)=\frac{1}{\beta^{\alpha}\Gamma(\alpha)}x^{\alpha-1}e^{-\frac{x}{\beta}},x>0$$
伽玛函数为：
$$\Gamma(x)=\int_{0}^{\infty }t^{x-1}e^{-t}dt$$
伽玛函数是阶乘在实数上的泛化。
概率密度函数
$$f(x)=x^{k-1}\frac{exp(-x/\theta )}{\Gamma (k)\theta^{k}}$$
```{r}
fun1 <- function(x){
  y <- dgamma(x,1,2)
  return(y)
}
  
fun2 <- function(x){
  y <- dgamma(x,2,2)
  return(y)
} 

fun3 <- function(x){
  y <- dgamma(x,5,1)
  return(y)
} 

ggplot(NULL, aes(x=x, colour = g)) +
  stat_function(data = data.frame(x=seq(0,10,length.out=100), 
                                  g = factor(1)), fun = fun1) +
  stat_function(data = data.frame(x=seq(0,10,length.out=100), 
                                  g = factor(2)), fun = fun2) +
  stat_function(data = data.frame(x=seq(0,10,length.out=100), 
                                  g = factor(3)), fun = fun3) +
  scale_colour_manual(values = c("red", "green","blue"), 
                      labels = c("red", "green","blue"))+
  ylab(label = "density")+
  labs(title="The Gamma Density Distribution")
```
累积分布函数
$$f(x)=\frac{\gamma (k,x/\theta )}{\Gamma (k)}$$
```{r}
fun1 <- function(x){
  y <- pgamma(x,1,2)
  return(y)
}
  
fun2 <- function(x){
  y <- pgamma(x,2,2)
  return(y)
} 

fun3 <- function(x){
  y <- pgamma(x,5,1)
  return(y)
} 

ggplot(NULL, aes(x=x, colour = g)) +
  stat_function(data = data.frame(x=seq(0,10,length.out=100), 
                                  g = factor(1)), fun = fun1) +
  stat_function(data = data.frame(x=seq(0,10,length.out=100), 
                                  g = factor(2)), fun = fun2) +
  stat_function(data = data.frame(x=seq(0,10,length.out=100), 
                                  g = factor(3)), fun = fun3) +
  scale_colour_manual(values = c("red", "green","blue"), 
                      labels = c("red", "green","blue"))+
  ylab(label = "density")+
  labs(title="The Gamma Cumulative Distribution Function")
```
分布检验
Kolmogorov-Smirnov连续分布检验:检验单一样本是不是服从某一预先假设的特定分布的方法。以样本数据的累计频数分布与特定理论分布比较，若两者间的差距很小，则推论该样本取自某特定分布族。该检验原假设为$H_{0}$:数据集符合指数分布，$H_{1}$:样本所来自的总体分布不符合指数分布。令$F0(x)$表示预先假设的理论分布，$Fn(x)$表示随机样本的累计概率(频率)函数.
统计量D为: $D=max|F0(x) - Fn(x)|$
D值越小，越接近0，表示样本数据越接近γ(伽玛)分布,p值，如果p-value小于显著性水平$\alpha$(0.05)，则拒绝$H_{0}$
```{r}
set.seed(1)
S<-rgamma(1000,1)
ks.test(S, "pgamma", 1)
```
结论: D值很小, p-value>0.05，不能拒绝原假设，所以数据集S符合shape=1伽玛分布！
```{r}
ks.test(S, "pgamma", 2)
```
结论:D值不够小, p-value<0.05，拒绝原假设，所以数据集S符合shape=2伽玛分布！

##weibull分布
weibull(韦伯)分布，又称韦氏分布或威布尔分布，是可靠性分析和寿命检验的理论基础。Weibull分布能被应用于很多形式，分布由形状、尺度（范围）和位置三个参数决定。其中形状参数是最重要的参数，决定分布密度曲线的基本形状，尺度参数起放大或缩小曲线的作用，但不影响分布的形状。Weibull分布通常用在故障分析领域( field of failure analysis)中；尤其是它可以模拟(mimic) 故障率(failture rate)持续( over time)变化的分布。故障率为：
一直为常量(constant over time)， 那么 $\alpha$ = 1， 暗示在随机事件中发生
一直减少(decreases over time)，那么$\alpha$ < 1， 暗示"早期失效(infant mortality)"
一直增加(increases over time)，那么$\alpha$ > 1， 暗示"耗尽(wear out)" 随着时间的推进，失败的可能性变大
概率密度函数
$$f(x;\lambda,k)=\left\{\begin{matrix}
{k/\lambda (x/\lambda)^{k-1}e^{-(x/\lambda)^{k}}}, \quad x\geq 0
 & \\ 0,\quad x<0
 & 
\end{matrix}\right.$$
```{r}
fun1 <- function(x){
  y <- dweibull(x,0.5)
  return(y)
}
  
fun2 <- function(x){
  y <- dweibull(x,1)
  return(y)
} 

fun3 <- function(x){
  y <- dweibull(x,5)
  return(y)
} 

ggplot(NULL, aes(x=x, colour = g)) +
  stat_function(data = data.frame(x=seq(0,2.5,length.out=100), 
                                  g = factor(1)), fun = fun1) +
  stat_function(data = data.frame(x=seq(0,2.5,length.out=100), 
                                  g = factor(2)), fun = fun2) +
  stat_function(data = data.frame(x=seq(0,2.5,length.out=100), 
                                  g = factor(3)), fun = fun3) +
  scale_colour_manual(values = c("red", "green","blue"), 
                      labels = c("red", "green","blue"))+
  ylab(label = "density")+
  labs(title="The Weibull Density Distribution")
```
累积分布函数
$$ F(x)=1-e^{-(x/\lambda)^{k}}$$
```{r}
fun1 <- function(x){
  y <- pweibull(x,0.5)
  return(y)
}
  
fun2 <- function(x){
  y <- pweibull(x,1)
  return(y)
} 

fun3 <- function(x){
  y <- pweibull(x,5)
  return(y)
} 

ggplot(NULL, aes(x=x, colour = g)) +
  stat_function(data = data.frame(x=seq(0,2.5,length.out=100), 
                                  g = factor(1)), fun = fun1) +
  stat_function(data = data.frame(x=seq(0,2.5,length.out=100), 
                                  g = factor(2)), fun = fun2) +
  stat_function(data = data.frame(x=seq(0,2.5,length.out=100), 
                                  g = factor(3)), fun = fun3) +
  scale_colour_manual(values = c("red", "green","blue"), 
                      labels = c("red", "green","blue"))+
  ylab(label = "density")+
  labs(title="The Weibull Cumulative Distribution Function")
```
分布检验
Kolmogorov-Smirnov连续分布检验:检验单一样本是不是服从某一预先假设的特定分布的方法。以样本数据的累计频数分布与特定理论分布比较，若两者间的差距很小，则推论该样本取自某特定分布族。该检验原假设为$H_{0}$:数据集符合指数分布，$H_{1}$:样本所来自的总体分布不符合指数分布。令$F0(x)$表示预先假设的理论分布，$Fn(x)$表示随机样本的累计概率(频率)函数.
统计量D为: $D=max|F0(x) - Fn(x)|$
D值越小，越接近0，表示样本数据越接近weibull分布,p值，如果p-value小于显著性水平$\alpha$(0.05)，则拒绝$H_{0}$
```{r}
set.seed(1)
S<-rweibull(1000,1)
ks.test(S, "pweibull",1)
```
结论: D值很小, p-value>0.05，不能拒绝原假设，所以数据集S符合shape=1的weibull分布！

## F分布
F-分布（F-distribution）是一种连续概率分布，被广泛应用于似然比率检验，特别是ANOVA中。F分布定义为：设X、Y为两个独立的随机变量，X服从自由度为k1的卡方分布，Y服从自由度为k2的卡方分布，这2 个独立的卡方分布被各自的自由度除以后的比率这一统计量的分布。即： 上式F服从第一自由度为k1，第二自由度为k2的F分布。
F分布是一种非对称分布它有两个自由度，即n1 -1和n2-1，相应的分布记为F（ n1 –1， n2-1）， n1 –1通常称为分子自由度， n2-1通常称为分母自由度
F分布是一个以自由度n1 –1和n2-1为参数的分布族，不同的自由度决定了F 分布的形状
F分布的倒数性质：$F\alpha,df1,df2=1/F1-\alpha,df1,df2[1]$
概率密度函数
$$f(x)=\frac{\sqrt{\frac{d1x^{d1}d2^{d2}}{(d1x+d2)^{d1+d2}}}}{xB(\frac{d1}{2},\frac{d2}{2})}$$
B是Beta函数(beta function)
```{r}
fun1 <- function(x){
  y <- -df(x,1,1,0)
  return(y)
}
  
fun2 <- function(x){
  y <- -df(x,1,1,2)
  return(y)
} 

fun3 <- function(x){
  y <- -df(x,2,2,2)
  return(y)
} 

ggplot(NULL, aes(x=x, colour = g)) +
  stat_function(data = data.frame(x=seq(0,5,length.out=100), 
                                  g = factor(1)), fun = fun1) +
  stat_function(data = data.frame(x=seq(0,5,length.out=100), 
                                  g = factor(2)), fun = fun2) +
  stat_function(data = data.frame(x=seq(0,5,length.out=100), 
                                  g = factor(3)), fun = fun3) +
  scale_colour_manual(values = c("red", "green","blue"), 
                      labels = c("red", "green","blue"))+
  ylab(label = "density")+
  labs(title="The F Density Distribution")
```
累积分布函数
$$F(x)=I\frac{d1x}{d1x+d2}(d1/2,d2/2)$$
I是不完全Beta函数
```{r}
fun1 <- function(x){
  y <- -pf(x,1,1,0)
  return(y)
}
  
fun2 <- function(x){
  y <- -pf(x,1,1,2)
  return(y)
} 

fun3 <- function(x){
  y <- -pf(x,2,2,2)
  return(y)
} 

ggplot(NULL, aes(x=x, colour = g)) +
  stat_function(data = data.frame(x=seq(0,5,length.out=100), 
                                  g = factor(1)), fun = fun1) +
  stat_function(data = data.frame(x=seq(0,5,length.out=100), 
                                  g = factor(2)), fun = fun2) +
  stat_function(data = data.frame(x=seq(0,5,length.out=100), 
                                  g = factor(3)), fun = fun3) +
  scale_colour_manual(values = c("red", "green","blue"), 
                      labels = c("red", "green","blue"))+
  ylab(label = "density")+
  labs(title="The F Cumulative Distribution Function")
```
分布检验
Kolmogorov-Smirnov连续分布检验:检验单一样本是不是服从某一预先假设的特定分布的方法。以样本数据的累计频数分布与特定理论分布比较，若两者间的差距很小，则推论该样本取自某特定分布族。该检验原假设为$H_{0}$:数据集符合指数分布，$H_{1}$:样本所来自的总体分布不符合指数分布。令$F0(x)$表示预先假设的理论分布，$Fn(x)$表示随机样本的累计概率(频率)函数.
统计量D为: $D=max|F0(x) - Fn(x)|$
D值越小，越接近0，表示样本数据越接近F分布,p值，如果p-value小于显著性水平$\alpha$(0.05)，则拒绝$H_{0}$
```{r}
set.seed(1)
S<-rf(1000,1,1,2)
ks.test(S, "pf", 1,1,2)
```

## T分布
学生t-分布（Student's t-distribution），可简称为t分布。应用在估计呈正态分布的总体的平均数。它是对两个样本均值差异进行显著性测试的学生t检定的基础。学生t检定改进了Z检定（Z-test），因为Z检定以总体标准差已知为前提。虽然在样本数量大（超过30个）时，可以应用Z检定来求得近似值，但Z检定用在小样本会产生很大的误差，因此必须改用学生t检定以求准确。在总体标准差未知的情况下，不论样本数量大或小皆可应用学生t检定。在待比较的数据有三组以上时，因为误差无法压低，此时可以用变异数分析（ANOVA）代替学生t检定。
概率密度函数
$$f(x)=\frac{\Gamma ((\nu+1)/2)}{\sqrt{\nu \pi }\Gamma (\nu/2)(1+x^{2}/\nu)^{(v1+1)/2}}$$
$v$ 等于n − 1。 T的分布称为t-分布。参数$\nu$ 一般被称为自由度。
$\gamma$是伽玛函数。
```{r}
fun1 <- function(x){
  y <-dt(x,1,0)
  return(y)
}
  
fun2 <- function(x){
  y <-dt(x,5,0)
  return(y)
} 

fun3 <- function(x){
  y <-dt(x,5,2)
  return(y)
} 

ggplot(NULL, aes(x=x, colour = g)) +
  stat_function(data = data.frame(x=seq(-5,5,length.out=100), 
                                  g = factor(1)), fun = fun1) +
  stat_function(data = data.frame(x=seq(-5,5,length.out=100), 
                                  g = factor(2)), fun = fun2) +
  stat_function(data = data.frame(x=seq(-5,5,length.out=100), 
                                  g = factor(3)), fun = fun3) +
  scale_colour_manual(values = c("red", "green","blue"), 
                      labels = c("red", "green","blue"))+
  ylab(label = "density")+
  labs(title="The T Density Distribution")
```
累积分布函数
$$f(x)=\frac{1}{2}+\frac{x\Gamma((\nu+1)/2)_{2}F_{1}(\frac{1}{2},(\nu+1)/2;\frac{3}{2};-\frac{x^{2}}{v})}{\sqrt{\nu \pi }\Gamma (\nu/2)}$$
$\nu$等于n − 1。 T的分布称为t-分布。参数$\nu$一般被称为自由度。
$\gamma$是伽玛函数。
```{r}
fun1 <- function(x){
  y <-pt(x,1,0)
  return(y)
}
  
fun2 <- function(x){
  y <-pt(x,5,0)
  return(y)
} 

fun3 <- function(x){
  y <-pt(x,5,2)
  return(y)
} 

ggplot(NULL, aes(x=x, colour = g)) +
  stat_function(data = data.frame(x=seq(-5,5,length.out=100), 
                                  g = factor(1)), fun = fun1) +
  stat_function(data = data.frame(x=seq(-5,5,length.out=100), 
                                  g = factor(2)), fun = fun2) +
  stat_function(data = data.frame(x=seq(-5,5,length.out=100), 
                                  g = factor(3)), fun = fun3) +
  scale_colour_manual(values = c("red", "green","blue"), 
                      labels = c("red", "green","blue"))+
  ylab(label = "density")+
  labs(title="The T Cumulative Distribution Function")
```
分布检验
Kolmogorov-Smirnov连续分布检验:检验单一样本是不是服从某一预先假设的特定分布的方法。以样本数据的累计频数分布与特定理论分布比较，若两者间的差距很小，则推论该样本取自某特定分布族。该检验原假设为$H_{0}$:数据集符合指数分布，$H_{1}$:样本所来自的总体分布不符合指数分布。令$F0(x)$表示预先假设的理论分布，$Fn(x)$表示随机样本的累计概率(频率)函数.
统计量D为: $D=max|F0(x) - Fn(x)|$
D值越小，越接近0，表示样本数据越接近T分布,p值，如果p-value小于显著性水平$\alpha$(0.05)，则拒绝$H_{0}$
```{r}
set.seed(1)
S<-rt(1000, 1,2)
ks.test(S, "pt", 1, 2)
```
结论: D值很小, p-value>0.05，不能拒绝原假设，所以数据集S符合df1=1, ncp=2的T分布！

##β(贝塔Beta)分布
贝塔分布(Beta Distribution)是指一组定义在(0,1)区间的连续概率分布，Beta分布有α和β两个参数$\alpha$,$\beta$>0，其中$\alpha$为成功次数加1，$\beta$为失败次数加1。Beta分布的一个重要应该是作为伯努利分布和二项式分布的共轭先验分布出现，在机器学习和数理统计学中有重要应用。贝塔分布中的参数可以理解为伪计数，伯努利分布的似然函数可以表示为，表示一次事件发生的概率，它为贝塔有相同的形式，因此可以用贝塔分布作为其先验分布。
概率密度函数
$$f(x)=\frac{1}{B(\alpha,\beta )}(x^{\alpha-1})(1-x)^{\beta-1}$$
随机变量X服从参数为$\alpha,\beta$，服从Beta分布
$\gamma$是伽玛函数
```{r}
fun1 <- function(x){
  y <-dbeta(x,0.5,0.5)
  return(y)
}
  
fun2 <- function(x){
  y <-dbeta(x,5,1)
  return(y)
} 

fun3 <- function(x){
  y <-dbeta(x,1,3)
  return(y)
} 

ggplot(NULL, aes(x=x, colour = g)) +
  stat_function(data = data.frame(x=seq(0,1,length.out=100), 
                                  g = factor(1)), fun = fun1) +
  stat_function(data = data.frame(x=seq(0,1,length.out=100), 
                                  g = factor(2)), fun = fun2) +
  stat_function(data = data.frame(x=seq(0,1,length.out=100), 
                                  g = factor(3)), fun = fun3) +
  scale_colour_manual(values = c("red", "green","blue"), 
                      labels = c("red", "green","blue"))+
  ylab(label = "density")+
  labs(title="The Beta Density Distribution")
```
累积分布函数
$$F(x;\alpha,\beta )=\frac{B_{x}(\alpha,\beta)}{B(\alpha,\beta)}=I_{x}(\alpha,\beta)$$
I是正则不完全Beta函数
```{r}
fun1 <- function(x){
  y <-pbeta(x,0.5,0.5)
  return(y)
}
  
fun2 <- function(x){
  y <-pbeta(x,5,1)
  return(y)
} 

fun3 <- function(x){
  y <-pbeta(x,1,3)
  return(y)
} 

ggplot(NULL, aes(x=x, colour = g)) +
  stat_function(data = data.frame(x=seq(0,1,length.out=100), 
                                  g = factor(1)), fun = fun1) +
  stat_function(data = data.frame(x=seq(0,1,length.out=100), 
                                  g = factor(2)), fun = fun2) +
  stat_function(data = data.frame(x=seq(0,1,length.out=100), 
                                  g = factor(3)), fun = fun3) +
  scale_colour_manual(values = c("red", "green","blue"), 
                      labels = c("red", "green","blue"))+
  ylab(label = "density")+
  labs(title="The Beta Cumulative Distribution Function")
```
分布检验
Kolmogorov-Smirnov连续分布检验:检验单一样本是不是服从某一预先假设的特定分布的方法。以样本数据的累计频数分布与特定理论分布比较，若两者间的差距很小，则推论该样本取自某特定分布族。该检验原假设为$H_{0}$:数据集符合指数分布，$H_{1}$:样本所来自的总体分布不符合指数分布。令$F0(x)$表示预先假设的理论分布，$Fn(x)$表示随机样本的累计概率(频率)函数.
统计量D为: $D=max|F0(x) - Fn(x)|$
D值越小，越接近0，表示样本数据越接近β(贝塔Beta)分布,p值，如果p-value小于显著性水平$\alpha$(0.05)，则拒绝$H_{0}$
```{r}
set.seed(1)
S<-rbeta(1000,1,2)
ks.test(S, "pbeta",1,2)
```
结论: D值很小, p-value>0.05，不能拒绝原假设，所以数据集S符合shape1=1, shape2=2的Beta分布！

## $\chi^2$(卡方)分布
总体$X\sim N(\mu,\sigma^{2})$,则样本的统计量$\frac{1}{\sigma ^{2}}\sum_{i=1}^{n}(X_{i}-\mu)$,服从自由度为n的$\chi^2$分布。样本统计量$\frac{1}{\sigma ^{2}}\sum_{i=1}^{n}(X_{i}-\bar{X})$,服从自由度为n-1的$\chi^2$分布。
若n个相互独立的随机变量$\varepsilon _{1},\varepsilon _{2},...,\varepsilon _{n}$ ，均服从标准正态分布（也称独立同分布于标准正态分布），则这n个服从标准正态分布的随机变量的平方和构成一新的随机变量，其分布规律称为$\chi^2$分布（chi-square distribution）。其中参数n称为自由度，自由度不同就是另一个$\chi^2$分布，正如正态分布中均值或方差不同就是另一个正态分布一样。
概率密度函数
$$f_{k}(x)=\frac{(1/2)^{k/2}}{\Gamma (k/2)}x^{k/2-1}e^{-x/2}$$
$\gamma$是伽玛函数
```{r}
fun1 <- function(x){
  y <-dchisq(x,1)
  return(y)
}
  
fun2 <- function(x){
  y <-dchisq(x,2)
  return(y)
} 

fun3 <- function(x){
  y <-dchisq(x,3)
  return(y)
} 

ggplot(NULL, aes(x=x, colour = g)) +
  stat_function(data = data.frame(x=seq(0,10,length.out=100), 
                                  g = factor(1)), fun = fun1) +
  stat_function(data = data.frame(x=seq(0,10,length.out=100), 
                                  g = factor(2)), fun = fun2) +
  stat_function(data = data.frame(x=seq(0,10,length.out=100), 
                                  g = factor(3)), fun = fun3) +
  scale_colour_manual(values = c("red", "green","blue"), 
                      labels = c("red", "green","blue"))+
  ylab(label = "density")+
  labs(title="The Chisq Density Distribution")
```
累积分布函数
$$f_{k}(x)=\frac{\gamma (k/2,x/2)}{\Gamma (k/2)}$$
$\gamma$是伽玛函数
```{r}
fun1 <- function(x){
  y <-pchisq(x,1)
  return(y)
}
  
fun2 <- function(x){
  y <-pchisq(x,2)
  return(y)
} 

fun3 <- function(x){
  y <-pchisq(x,3)
  return(y)
} 

ggplot(NULL, aes(x=x, colour = g)) +
  stat_function(data = data.frame(x=seq(0,10,length.out=100), 
                                  g = factor(1)), fun = fun1) +
  stat_function(data = data.frame(x=seq(0,10,length.out=100), 
                                  g = factor(2)), fun = fun2) +
  stat_function(data = data.frame(x=seq(0,10,length.out=100), 
                                  g = factor(3)), fun = fun3) +
  scale_colour_manual(values = c("red", "green","blue"), 
                      labels = c("red", "green","blue"))+
  ylab(label = "density")+
  labs(title="The Chisq Cumulative Distribution Function")
```
分布检验
Kolmogorov-Smirnov连续分布检验:检验单一样本是不是服从某一预先假设的特定分布的方法。以样本数据的累计频数分布与特定理论分布比较，若两者间的差距很小，则推论该样本取自某特定分布族。该检验原假设为$H_{0}$:数据集符合指数分布，$H_{1}$:样本所来自的总体分布不符合指数分布。令$F0(x)$表示预先假设的理论分布，$Fn(x)$表示随机样本的累计概率(频率)函数.
统计量D为: $D=max|F0(x) - Fn(x)|$
D值越小，越接近0，表示样本数据越接近$\chi^2$(卡方)分布,p值，如果p-value小于显著性水平$\alpha$(0.05)，则拒绝$H_{0}$
```{r}
set.seed(1)
S<-rchisq(1000,1)
ks.test(S, "pchisq",1)
```

##均匀分布
均匀分布(Uniform distribution)是均匀的，不偏差的一种简单的概率分布，分为：离散型均匀分布与连续型均匀分布。
 概率密度函数
 $$f(x)=\left\{\begin{matrix}\frac{1}{b-a} \quad for \quad a\leq x\leq b
 & \\ 0 \quad elsewhere
 & 
\end{matrix}\right.$$
```{r}
fun1 <- function(x){
  y <-dunif(x,0,1)
  return(y)
}
  
fun2 <- function(x){
  y <-dunif(x,0,0.5)
  return(y)
} 

fun3 <- function(x){
  y <-dunif(x,-3,1)
  return(y)
} 

ggplot(NULL, aes(x=x, colour = g)) +
  stat_function(data = data.frame(x=seq(0,10,length.out=100), 
                                  g = factor(1)), fun = fun1) +
  stat_function(data = data.frame(x=seq(0,10,length.out=100), 
                                  g = factor(2)), fun = fun2) +
  stat_function(data = data.frame(x=seq(0,10,length.out=100), 
                                  g = factor(3)), fun = fun3) +
  scale_colour_manual(values = c("red", "green","blue"), 
                      labels = c("red", "green","blue"))+
  ylab(label = "density")+
  labs(title="The Uniform Density Distribution")
```
累积分布函数
$$F(x)\left\{\begin{matrix} 0 \quad for \quad x< a
 & \\ \quad \frac{x-a}{b-a} \quad for \quad a\leq x < b
 & \\ 1 \quad for \quad x\geq b
 & 
\end{matrix}\right.$$
```{r}
fun1 <- function(x){
  y <-punif(x,0,1)
  return(y)
}
  
fun2 <- function(x){
  y <-punif(x,0,0.5)
  return(y)
} 

fun3 <- function(x){
  y <-punif(x,-3,1)
  return(y)
} 

ggplot(NULL, aes(x=x, colour = g)) +
  stat_function(data = data.frame(x=seq(0,10,length.out=100), 
                                  g = factor(1)), fun = fun1) +
  stat_function(data = data.frame(x=seq(0,10,length.out=100), 
                                  g = factor(2)), fun = fun2) +
  stat_function(data = data.frame(x=seq(0,10,length.out=100), 
                                  g = factor(3)), fun = fun3) +
  scale_colour_manual(values = c("red", "green","blue"), 
                      labels = c("red", "green","blue"))+
  ylab(label = "density")+
  labs(title="The Uniform Cumulative Distribution Function")
```
分布检验
Kolmogorov-Smirnov连续分布检验:检验单一样本是不是服从某一预先假设的特定分布的方法。以样本数据的累计频数分布与特定理论分布比较，若两者间的差距很小，则推论该样本取自某特定分布族。该检验原假设为$H_{0}$:数据集符合指数分布，$H_{1}$:样本所来自的总体分布不符合指数分布。令$F0(x)$表示预先假设的理论分布，$Fn(x)$表示随机样本的累计概率(频率)函数.
统计量D为: $D=max|F0(x) - Fn(x)|$
D值越小，越接近0，表示样本数据越接近均匀分布,p值，如果p-value小于显著性水平$\alpha$(0.05)，则拒绝$H_{0}$
```{r}
set.seed(1)
S<-runif(1000)
ks.test(S, "punif")
```
结论: D值很小, p-value>0.05，不能拒绝原假设，所以数据集S符合均匀分布！

例 某年级医学生解剖学考试成绩X(分)近似服从$N(65,10^{2})$，问解剖学成绩在85分以上的考生的概率是多少？
```{r}
pnorm(85,65,10,lower.tail = F) 
#pnorm()函数是正态分布的分布函数，用来计算对应分布下的概率
#lower.tail = F默认为T计算小于x的概率，F表示计算大于x的概率
```
解剖学成绩在85分以上的考生概率为`r round(pnorm(85,65,10,lower.tail = F) ,2)`

##Poisson分布
Poisson分布常用于描述单位时间、单位平面或单位空间中罕见事件的随机分布规律，Poisson分布的均数和方差相等。概率密度函数为
$$f(x)=\frac{e^{-\lambda}\lambda^x}{x!},x\in {0,1,2,3,...}$$

```{r warning=F}
ggplot(data.frame(x=c(0:10)),aes(x=x))+
  stat_function(fun=dpois,colour="red",args = list(lambda=1))+
  stat_function(fun=dpois,colour="green",args = list(lambda=2))+
  stat_function(fun=dpois,colour="blue",args = list(lambda=3))+
  ylab(label = "density")+
  labs(title="The Poisson Density Distribution")
```

累积分布函数
$$f(x)=e^{-\lambda}\sum_{i=0}^{|x|}\frac{\lambda^{i}}{i!},x\in {0,1,2,3,...}$$
```{r warning=F}
ggplot(data.frame(x= seq(-0.01, 5, 0.01)),aes(x=x))+
  stat_function(fun=ppois,colour="red",args = list(lambda=1))+
  stat_function(fun=ppois,colour="green",args = list(lambda=2))+
  stat_function(fun=ppois,colour="blue",args = list(lambda=3))+
  ylab(label = "density")+
  labs(title="The Poisson Cumulative Distribution Function")
```

例 随机变量X服从参数为3的Poisson分布，求概率P{x=6}.
```{r}
dpois(6,3)
```
参数为3的Poisson分布在X=6时的概率为`r dpois(6,3)`。

##数据分布直接的关系

![常见数据分布之间的关系](./distribution_chart.jpg)

##探索数据分布
要了解样本数据的总体分布情况，仅有特征统计量是不够的，还需要研究数据的分布状况。经验分布函数是指根据样本构造的概率分布函数，设$x_{1},x_{2},...,x_{n}$为一组样本，定义函数$m(x)$表示样本中小于或者等于$x$的样本个数，则称函数
$$F_{n}^{x}=\frac{m(x)}{n}$$
为样本$x_{1},x_{2},...,x_{n}$的经验分布函数。由Glivenko-Cantelli定理，当样本数组数足够大时，经验分布函数是总体分布函数的一个良好的近似。对数据分布的探索可参考下图中的决策树

![数据分布探索决策树](./distribution.jpg)

例 探索fitdistrplus中groundbeef的数据分布。
思路：首先判断数据的特点选择较为可能的分布，然后利用fitdist()获得可能分布的参数估计，再利用gofstat()选择较优的分布，最后可用ks.test()进行验证。
```{r}
data(groundbeef)
serving <- groundbeef$serving

fitW <- fitdist(serving, "weibull")
fitg <- fitdist(serving, "gamma")
fitln <- fitdist(serving, "lnorm")
summary(fitW)
summary(fitg)
summary(fitln)
#plot(fitg, demp = TRUE)
#plot(fitg, histo = FALSE, demp = TRUE)
cdfcomp(list(fitW, fitg, fitln), legendtext=c("Weibull", "gamma", "lognormal"))
denscomp(list(fitW, fitg, fitln), legendtext=c("Weibull", "gamma", "lognormal"))
qqcomp(list(fitW, fitg, fitln), legendtext=c("Weibull", "gamma", "lognormal"))
ppcomp(list(fitW, fitg, fitln), legendtext=c("Weibull", "gamma", "lognormal"))
gofstat(list(fitW, fitg, fitln), fitnames=c("Weibull", "gamma", "lognormal"))
```
选择AIC和BIC值较小的gamma分布

```{r echo=F}
try(detach(package:fitdistrplus))
try(detach(package:CircStats))
try(detach(package:ggplot2))
```

